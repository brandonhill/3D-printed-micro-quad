/******************************************************************************
 * Inspired by the RS90
 *
 * See: https://www.rcgroups.com/forums/showthread.php?2474278-RS90-The-Ultimate-Indoor-FPV-Quad
 */

include <../BH-Lib/all.scad>;

/******************************************************************************
 * MAIN
 */

BOOM_ANGLE = 35;

CAM_ANGLE = 25;

CANOPY_ROUNDING = 5;
CANOPY_THICKNESS = 0.6;
CANOPY_DIM = [
	0, // not used
	24,
	35
];

COMPONENT_CLEARANCE = 1;

PRINT_LAYER = 0.2;
PRINT_NOZZLE = 0.5;

PROP_RAD = 56 / 2;

TOLERANCE_CLOSE = 0.2;
TOLERANCE_FIT = 0.25;
TOLERANCE_CLEAR = 0.3;

SIZE_DIA = 100;

/******************************************************************************
 * COMPONENTS
 */

BATT_DIM_3100 = [68, 19, 19];
BATT_WGT_3100 = 46.3;

BATT_DIM = BATT_DIM_3100;
BATT_STRAP_DIM = [15.5, 1.5];
BATT_WEIGHT = BATT_WGT_3100;
BATT_WIRE_RAD = wire_rad(18);

BUZZER_DIM = [9, 9, 5];

CAM_FOV = 120;
CAM_DIM = CAM_RUNCAM_SWIFT_MICRO_DIM;
CAM_MOUNT_THICKNESS = 3; // based on cam mount screw length
CAM_PIVOT_OFFSET = CAM_RUNCAM_SWIFT_MICRO_PIVOT_OFFSET;
CAM_SCREW_RAD = 1;

ESC_DIM = ESC_TEENY_6A_4IN1_DIM;
ESC_BOARD_DIM = ESC_TEENY_6A_4IN1_BOARD_DIM;

FC_BOARD_DIM = FC_TEENY_F4_BOARD_DIM;
FC_DIM = FC_TEENY_F4_DIM;
FC_HOLE_SPACING = FC_TEENY_F4_HOLE_SPACING;
FC_SCREW_DIM = SCREW_M2_SOCKET_DIM;
FC_SCREW_PITCH = THREAD_PITCH_M2_COARSE;
FC_SCREW_SURROUND = 0.6;

FRAME_INNER_ROUNDING = 3;
FRAME_OUTER_ROUNDING = 10;
FRAME_PROP_SURROUD_FN = $fn;
FRAME_SCREW_DIM = SCREW_M2_SOCKET_DIM;
FRAME_SCREW_LENGTH = 8;
FRAME_SCREW_SURROUND = 1.5;
FRAME_THICKNESS = 3;
FRAME_WIDTH = 2; // edge

MOTOR_AXLE_CLEARANCE_DIM = [3.5, 1.2];
MOTOR_CLEARANCE = 0;
MOTOR_HEIGHT = MOTOR_SUNNYSKY_0705_HEIGHT;
MOTOR_MOUNT_RAD = MOTOR_SUNNYSKY_0705_MOUNT_RAD;
MOTOR_MOUNT_THICKNESS = MOTOR_SUNNYSKY_0705_MOUNT_THICKNESS;
MOTOR_RAD = MOTOR_SUNNYSKY_0705_RAD;
MOTOR_SCREW_DIM = SCREW_M1_6_PAN_DIM;
MOTOR_SCREW_RAD = MOTOR_SUNNYSKY_0705_MOUNT_HOLE_RAD;
MOTOR_SCREW_LENGTH = 3;
MOTOR_SCREW_SURROUND = 1;
MOTOR_SHAFT_HEIGHT = MOTOR_SUNNYSKY_0705_SHAFT_HEIGHT;
MOTOR_SHAFT_RAD = MOTOR_SUNNYSKY_0705_SHAFT_RAD;
MOTOR_WIRES_HOLE_RAD = 1.25; // for all 3 wires
MOTOR_WIRES_HOLE_OFFSET = 10; // x position (position under motor supports)

POWER_WIRE_ANCHOR_LENGTH = 3;
POWER_WIRE_RAD = wire_rad(18);

PROP_CLEARANCE_BOTTOM = 10;
PROP_CLEARANCE_SIDE = 1;

RX_DIM = [15.5, 10.2, 3.5];

USB_PLUG_DIM = [10.25, 6.25]; // profile; for cutout

VTX_DIM = VTX_VTX03_DIM;

/******************************************************************************
 * SETUP (order is important)
 */

SIZE = [
	sin(BOOM_ANGLE) * SIZE_DIA,
	cos(BOOM_ANGLE) * SIZE_DIA
];

FRAME_HEIGHT = MOTOR_HEIGHT + MOTOR_SHAFT_HEIGHT + PROP_CLEARANCE_BOTTOM + FRAME_THICKNESS * 2;
FRAME_STANDOFF_LENGTH = FRAME_HEIGHT - FRAME_THICKNESS * 2;

FC_POS = [0, 0, FRAME_THICKNESS + 2];
FC_ROT = [];

ESC_POS = [
	FC_POS[0],
	FC_POS[1],
	FC_POS[2] + FC_DIM[2] / 2 + COMPONENT_CLEARANCE + ESC_DIM[2] / 2];
ESC_ROT = [0, 0, 0];
ESC_STANDOFF_LENGTH = ESC_POS[2] - (FC_POS[2] + FC_BOARD_DIM[2]) - TOLERANCE_CLOSE * 2;

MOTOR_POS = let(h = SIZE_DIA / 2)
	[sin(BOOM_ANGLE) * h,
	cos(BOOM_ANGLE) * h,
	FRAME_HEIGHT - FRAME_THICKNESS
	];
MOTOR_ROT = [180, 0, 60];

RX_POS = [
	FC_POS[0] + FC_DIM[0] / 2 + 6 + RX_DIM[0] / 2,
	0,
	CANOPY_THICKNESS + COMPONENT_CLEARANCE + RX_DIM[2] / 2];
RX_ROT = [0, 0, 0];

BUZZER_POS = [
	RX_POS[0],
	0,
	RX_POS[2] + RX_DIM[2] / 2 + COMPONENT_CLEARANCE + BUZZER_DIM[2]];
BUZZER_ROT = [180, 0, 180];

CAM_CUTOUT_RAD = CAM_RUNCAM_SWIFT_MICRO_RAD[len(CAM_RUNCAM_SWIFT_MICRO_RAD) - 1] + 0.5;

CAM_BATTERY_OFFSET = 0; // move forward to clear battery
CAM_POS = [
	BATT_DIM[0] / 2 + CAM_DIM[2] / 2 + CAM_BATTERY_OFFSET,
	0,
	CANOPY_THICKNESS + COMPONENT_CLEARANCE + CAM_DIM[1] / 2 + 2];
CAM_ROT = [0, -CAM_ANGLE];

FRAME_FRONT_POS = CAM_POS[0] + CANOPY_ROUNDING;

PROP_POS = [MOTOR_POS[0], MOTOR_POS[1], MOTOR_POS[2] - 11.75]; // TODO: position by specs
PROP_ROT = [];

VTX_POS = [
	FC_POS[0] - (FC_DIM[0] / 2 + COMPONENT_CLEARANCE * 2 + VTX_DIM[1] / 2),
	0,
	CANOPY_THICKNESS + COMPONENT_CLEARANCE + VTX_DIM[2] / 2];
VTX_ROT = [0, 0, 90];

// CG

BATT_STRAP_WEIGHT = 1.2;
BUZZER_WEIGHT = 1;
CAM_WEIGHT = 5.6;
ESC_WEIGHT = 2;
FC_WEIGHT = 2;
MOTOR_WEIGHT = 3;
PROP_WEIGHT = 0.3;
RX_WEIGHT = 1;
VTX_WEIGHT = 2; // inc. dipole antenna

WEIGHT =
	BATT_WEIGHT +
	BATT_STRAP_WEIGHT +
	BUZZER_WEIGHT +
	CAM_WEIGHT +
	ESC_WEIGHT + // 4 in 1
	FC_WEIGHT +
	MOTOR_WEIGHT * 4 +
	PROP_WEIGHT * 4 +
	RX_WEIGHT +
	VTX_WEIGHT
	;


// NOT WORKING! TODO: fix
//@recursive
function move_batt_until_cg_near_centre(batt_pos, tolerance = 1) =
	let(
		curr_cg = cg(batt_pos),
		offset = abs(curr_cg[0]))
	offset > tolerance ?
// 	offset > tolerance && curr_cg[0] < BATT_POS_MAX[0] ?
		move_batt_until_cg_near_centre([
			batt_pos[0] + max(0, offset) * sign(offset),
			batt_pos[1],
			batt_pos[2]],
			tolerance)
		:
		batt_pos;


function cg(batt_pos) = (
	batt_pos * (BATT_WEIGHT + BATT_STRAP_WEIGHT) +
	BUZZER_POS * BUZZER_WEIGHT +
	CAM_POS * CAM_WEIGHT +

// 	[ ESC_POS[0],  ESC_POS[1], ESC_POS[2]] * ESC_WEIGHT +
// 	[-ESC_POS[0],  ESC_POS[1], ESC_POS[2]] * ESC_WEIGHT +
// 	[ ESC_POS[0], -ESC_POS[1], ESC_POS[2]] * ESC_WEIGHT +
// 	[-ESC_POS[0], -ESC_POS[1], ESC_POS[2]] * ESC_WEIGHT +

	ESC_POS * ESC_WEIGHT + // 4 in 1
	FC_POS * FC_WEIGHT +

	[ MOTOR_POS[0],  MOTOR_POS[1], MOTOR_POS[2]] * MOTOR_WEIGHT +
	[-MOTOR_POS[0],  MOTOR_POS[1], MOTOR_POS[2]] * MOTOR_WEIGHT +
	[ MOTOR_POS[0], -MOTOR_POS[1], MOTOR_POS[2]] * MOTOR_WEIGHT +
	[-MOTOR_POS[0], -MOTOR_POS[1], MOTOR_POS[2]] * MOTOR_WEIGHT +

	[ PROP_POS[0],  PROP_POS[1], PROP_POS[2]] * PROP_WEIGHT +
	[-PROP_POS[0],  PROP_POS[1], PROP_POS[2]] * PROP_WEIGHT +
	[ PROP_POS[0], -PROP_POS[1], PROP_POS[2]] * PROP_WEIGHT +
	[-PROP_POS[0], -PROP_POS[1], PROP_POS[2]] * PROP_WEIGHT +

	RX_POS * RX_WEIGHT +
	VTX_POS * VTX_WEIGHT
	) / WEIGHT;

BATT_POS_INITIAL = [-6, 0, ESC_POS[2] + ESC_BOARD_DIM[2] +
ESC_DIM[2] / 2 + BATT_STRAP_DIM[1] + BATT_DIM[2] / 2];
// BATT_POS = move_batt_until_cg_near_centre(BATT_POS_INITIAL);

BATT_POS = BATT_POS_INITIAL;
BATTERY_ROT = [90, 0];

CG = cg(BATT_POS);

FRAME_BACK_POS = BATT_POS[0] - BATT_DIM[0] / 2;
