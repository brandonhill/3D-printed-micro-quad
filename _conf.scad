/******************************************************************************
 * Inspired by the RS90
 *
 * See: https://www.rcgroups.com/forums/showthread.php?2474278-RS90-The-Ultimate-Indoor-FPV-Quad
 */

include <../BH-Lib/all.scad>;

PRINT_LAYER = 0.2;
PRINT_NOZZLE = 0.5;

TOLERANCE_CLOSE = 0.2;
TOLERANCE_FIT = 0.25;
TOLERANCE_CLEAR = 0.3;

BOOM_ANGLE = 35;
PROP_RAD = 56 / 2;//2.8 * MMPI / 2;
SIZE_DIA = 100;

SIZE = [
	sin(BOOM_ANGLE) * SIZE_DIA,
	cos(BOOM_ANGLE) * SIZE_DIA
];

COMPONENT_CLEARANCE = 1;
PROP_CLEARANCE_BOTTOM = 10;
PROP_CLEARANCE_SIDE = 1;
WALLS_MIN = PRINT_NOZZLE;

// COMPONENT DIMENSIONS

BATT_DIM_3100 = [68, 19, 19];
BATT_WGT_3100 = 46.3;

BATT_DIM = BATT_DIM_3100;
BATT_STRAP_DIM = [10, 2];
BATT_WEIGHT = BATT_WGT_3100;
BATT_WIRE_RAD = 1;

// BODY_DIM = [100, 20, 35];

BUZZER_DIM = [9, 9, 5];

CAM_FOV = 120;
CAM_DIM = CAM_RUNCAM_SWIFT_MICRO_DIM;
CAM_PIVOT_OFFSET = CAM_RUNCAM_SWIFT_MICRO_PIVOT_OFFSET;
CAM_SCREW_RAD = 1;

ESC_DIM = [23, 28, 5]; // Teeny 1s 6A

FC_DIM = [23, 23, 5]; // Teeny 1s F3
FC_HOLE_SPACING = [16, 16];

// CONFIG

CAM_ANGLE = 25;
CAM_MOUNT_THICKNESS = 3; // based on cam mount screw length

CANOPY_ROUNDING = 5;
CANOPY_THICKNESS = 1;
CANOPY_DIM = [
	0, // not used
	24,
	35
];

FRAME_INNER_ROUNDING = 3;
FRAME_OUTER_ROUNDING = 10;
FRAME_PROP_SURROUD_FN = $fn;
// FRAME_PROP_SURROUD_FN = 7;
FRAME_SCREW_DIM = SCREW_M2_DIM;
FRAME_SCREW_LENGTH = 10;
FRAME_SCREW_SURROUND = 2;
FRAME_THICKNESS = 3;
FRAME_THICKNESS_MIN = 1;
FRAME_WIDTH = 2; // edge

/**
  * WARNING: Setting CHAMFER_ON uses `minkowski()`, and is very slow. Recommended to set
  * only for final render.
  */
CHAMFER_XY = 3;
CHAMFER_Z = (FRAME_WIDTH / 2) - 0.1;
CHAMFER_ON = false;
// CHAMFER_ON = true;

MOTOR_ANGLE = BOOM_ANGLE; // just coincidence at these specs
MOTOR_CLEARANCE = 0;
MOTOR_HEIGHT = MOTOR_SUNNYSKY_0705_HEIGHT;
MOTOR_MOUNT_RAD = MOTOR_SUNNYSKY_0705_MOUNT_RAD;
MOTOR_MOUNT_THICKNESS = FRAME_THICKNESS;
MOTOR_RAD = MOTOR_SUNNYSKY_0705_RAD;
MOTOR_SCREW_RAD = MOTOR_SUNNYSKY_0705_MOUNT_HOLE_RAD;
MOTOR_SHAFT_HEIGHT = MOTOR_SUNNYSKY_0705_SHAFT_HEIGHT;
MOTOR_WIRES_HOLE_RAD = 1.5; // for all 3 wires
MOTOR_WIRES_HOLE_OFFSET = 11; // x position (orient under motor supports)

POST_RAD = 2.5;

POWER_WIRE_RAD = 1;

RX_DIM = [23, 11, 3];

VTX_DIM = VTX_VTX03_DIM;

// CALCULATED (order is important)

BUZZER_POS = [
	BATT_DIM[0] / 2 - BUZZER_DIM[0],
	0,
	FRAME_THICKNESS_MIN + TOLERANCE_FIT +  BUZZER_DIM[2]];
BUZZER_ROT = [180, 0, 180];

// FC_POS = [0, 0, FRAME_THICKNESS_MIN + BATT_DIM[2] + COMPONENT_CLEARANCE + FC_DIM[2] / 2];
FC_POS = [0, 0, FRAME_THICKNESS + FC_DIM[2] / 2];
FC_ROT = [];

ESC_POS = [
	FC_POS[0],
	FC_POS[1],
	FC_POS[2] + FC_DIM[2] / 2 + COMPONENT_CLEARANCE * 2 + ESC_DIM[2] / 2,
];
ESC_ROT = [0, 0, 0];

FRAME_HEIGHT = MOTOR_HEIGHT + MOTOR_SHAFT_HEIGHT + PROP_CLEARANCE_BOTTOM + FRAME_THICKNESS * 2;

MOTOR_POS = let(h = SIZE_DIA / 2)
	[sin(BOOM_ANGLE) * h,
	cos(BOOM_ANGLE) * h,
	FRAME_HEIGHT - MOTOR_MOUNT_THICKNESS
	];
MOTOR_ROT = [180, 0, 60];

RX_POS = [
	FC_POS[0] + (FC_DIM[0] / 2 + COMPONENT_CLEARANCE * 2 + RX_DIM[0] / 2),
	0,
	BUZZER_POS[2] + COMPONENT_CLEARANCE + RX_DIM[2] / 2];
RX_ROT = [0, 0, 0];

CAM_CUTOUT_RAD = CAM_RUNCAM_SWIFT_MICRO_RAD[len(CAM_RUNCAM_SWIFT_MICRO_RAD) - 1] + 0.5;
// CAM_INSET = 3; // guard clearance, should accommodate full rotation

CAM_BATTERY_OFFSET = 0;//2; // move forward to clear battery
CAM_POS = [
	BATT_DIM[0] / 2 + CAM_DIM[2] / 2 + CAM_BATTERY_OFFSET,
	0,
// 	FRAME_HEIGHT / 2
	FRAME_THICKNESS_MIN + COMPONENT_CLEARANCE + CAM_DIM[1] / 2 + 2
	];
CAM_ROT = [0, -CAM_ANGLE];

FRAME_FRONT_POS = CAM_POS[0] + CANOPY_ROUNDING;

VTX_POS = [
	FC_POS[0] - (FC_DIM[0] / 2 + COMPONENT_CLEARANCE * 2 + VTX_DIM[1] / 2),
	0,
	FRAME_THICKNESS_MIN + COMPONENT_CLEARANCE + VTX_DIM[2] / 2
	];
VTX_ROT = [0, 0, 90];

// CG

BUZZER_WEIGHT = 1;
CAM_WEIGHT = 5.6;
ESC_WEIGHT = 2;
FC_WEIGHT = 2;
MOTOR_WEIGHT = 3;
RX_WEIGHT = 1;
VTX_WEIGHT = 2; // inc. dipole antenna

WEIGHT =
	BATT_WEIGHT +
	BUZZER_WEIGHT +
	CAM_WEIGHT +
	ESC_WEIGHT + // 4 in 1
	FC_WEIGHT +
	MOTOR_WEIGHT * 4 +
	RX_WEIGHT +
	VTX_WEIGHT
	;

//@recursive
function move_batt_until_cg_near_centre(batt_pos, tolerance = 1) =
	let(
		curr_cg = cg(batt_pos),
		offset = abs(curr_cg[0]))
	offset > tolerance ?
// 	offset > tolerance && curr_cg[0] < BATT_POS_MAX[0] ?
		move_batt_until_cg_near_centre([
			batt_pos[0] + max(0, offset) * sign(offset),
			batt_pos[1],
			batt_pos[2]],
			tolerance)
		:
		batt_pos;


function cg(batt_pos) = (
	batt_pos * BATT_WEIGHT +
	BUZZER_POS * BUZZER_WEIGHT +
	CAM_POS * CAM_WEIGHT +

// 	[ ESC_POS[0],  ESC_POS[1], ESC_POS[2]] * ESC_WEIGHT +
// 	[-ESC_POS[0],  ESC_POS[1], ESC_POS[2]] * ESC_WEIGHT +
// 	[ ESC_POS[0], -ESC_POS[1], ESC_POS[2]] * ESC_WEIGHT +
// 	[-ESC_POS[0], -ESC_POS[1], ESC_POS[2]] * ESC_WEIGHT +

	ESC_POS * ESC_WEIGHT + // 4 in 1

	FC_POS * FC_WEIGHT +
	[ MOTOR_POS[0],  MOTOR_POS[1], MOTOR_POS[2]] * MOTOR_WEIGHT +
	[-MOTOR_POS[0],  MOTOR_POS[1], MOTOR_POS[2]] * MOTOR_WEIGHT +
	[ MOTOR_POS[0], -MOTOR_POS[1], MOTOR_POS[2]] * MOTOR_WEIGHT +
	[-MOTOR_POS[0], -MOTOR_POS[1], MOTOR_POS[2]] * MOTOR_WEIGHT +
	RX_POS * RX_WEIGHT +
	VTX_POS * VTX_WEIGHT
	) / WEIGHT
;

// BATT_POS_INITIAL = [-4, 0, FRAME_THICKNESS_MIN + BATT_DIM[2] / 2];
BATT_POS_INITIAL = [-6, 0, ESC_POS[2] + ESC_DIM[2] / 2 + COMPONENT_CLEARANCE + FRAME_THICKNESS_MIN + COMPONENT_CLEARANCE + BATT_DIM[2] / 2 + 1];
// BATT_POS = move_batt_until_cg_near_centre(BATT_POS_INITIAL);
BATT_POS = BATT_POS_INITIAL;
BATTERY_ROT = [90, 0];

CG = cg(BATT_POS);

FRAME_BACK_POS = BATT_POS[0] - BATT_DIM[0] / 2;
